
# 상속 심화

## 여러 개의 기본 클래스를 동시에 상속

- 여러 개의 기본 클래스를 직접 상속받는 방법
- 아버지와 어머니 클래스를 아들 클래스가 물려받는 것
- JAVA, C#, Swift 등에서는 지원하지 않음

## 여러 개의 기본 클래스를 상속 받는 파생 클래스 형식

```cpp
class 파생클래스명 : 상속접근제어1 기본 클래스명1,
        상속접근제어2 기본클래스명2, ...
        상속 접근제어N 기본 클래스명N, ...
    {
        클래스 선언;
    };
```

```cpp
class Child : public Father, public Mother
{   // 자식 클래스가 아버지와 어머니 클래스로부터
    클래스 선언; // public으로 상속 받는다
};
```

## 파생 클래스 생성자에서 여러 개의 기본 클래스 생성자에 매개변수 전달 형식

- 여러 개의 기본 클래스를 상속 받을 때, 생성자는 기본 클래스가 지정된 순서대로 왼쪽에서 오른쪽으로 실행된다 ->
- 소멸자는 역순으로 실행된다. <-
- 파생클래스생성자(매개변수 리스트):기본클래스1 생성자(매개변수 리스트),
                                기본클래스2 생성자(매개변수 리스트),
                                기본클래스N 생성자(매개변수 리스트)

# Overrriding: 가상함수(Virtual Function) static

## 가상함수(Virtual Function)의 필요성

- 클래스를 상속 받아서 쓰는데, 상속 받은 클래스의 함수 중 고치고 싶은 함수가 있을 때
- 기존 클래스의 모든 내용을 모두 현재 프로그램에 사용할 수 있는데, 특정 함수가 마음에 들지 않음
- 기존의 클래스를 고치느니 상속을 받고, 가상함수를 이용하여 기존의 함수를 고쳐서 사용
- 상속 받은 함수(부모)를 실행하지 않고 자신(자식)의 함수를 실행
- 가상함수의 구현을 중복(overriding)이라고 함

## 오버라이딩: 가상함수 구현

- 가상함수는 기본(부모) 클래스 내에서 정의된 멤버함수를 파생(자식) 클래스에서 재정의하고자 할 때 사용한다.
- 기본 클래스의 멤버함수와 같은 이름의 함수를 파생 클래스에서 재정의하여 사용한다.
- 파생 클래스 내에서 가상함수의 재정의는 함수 중첩 기능과 비슷하지만 파생 클래스에서 재정의되는 가상함수는 기본 클래스와 함수의 리턴값, 매개변수 개수, 형이 완전히 같아야 한다.
- 가상함수의 구현을 중복(overriding)이라 한다.

# 바인딩

## 바인딩(binding)

- 변수와 함수에 대한 메모리 할당이나 함수 호출이 발생했을 때 실제로 처리해야 하는 명령어들이 결정되는 시점
- 정적(static) 바인딩, early
  - 컴파일시 변수의 위치와 함수가 실행할 명령이 결정되는 경우
  - static 변수, overloading
- 동적(dynamic) 바인딩, late
  - 실제 실행할 때(run time) 결정되는 경우
  - 지역 변수, overriding

# 정적멤버변수

## 정적(static) 멤버변수

```cpp
class Point{
    int x;
    int y;
    static int count; // 정적멤버변수
public:
    Point(int i, int j) { x = 1; y = j;}
    int getX() { return x; }
    int getY() { return y; }
};
```

- 클래스의 멤버 변수 선언문에 static이라는 키워드 붙임
- C언어의 static변수와 의미가 다름
- 객체들이 정보를 공유할 목적으로 사용하는 변수

## 정적 멤버변수의 특징

- 모든 객체가 공유하는 멤버변수
- 한 클래스로부터 객체가 여러 개 만들어지더라도 이 멤버변수는 하나만 생성됨
- 여러 객체들에서 공유해야 하는 정보는 정적 멤버변수로 선언

```cpp
class Dog{
private:
    static int age;
public:
    int getAge() { return age; }
    void setAge(int a) { age = a; }
};
int main() {
    Dog merry, happy;
}
```

# 가상함수

## 가상함수(Virtual Function)

- 오버라이딩을 구현하는 방법
- 동적(실행시) 바인딩, late binding
- 가상함수를 정의하기 위해서는 기본 클래스의 멤버함수 앞에 'virtual'이라는 키워드를 씀
- 가상함수는 하나의 이름(인터페이스)으로 여러 개의 수단과 방법을 제공하는 객체지향 프로그래밍의 다형성을 구현하는 한 방법
- 기본 클래스에서 상속 받았는데 파생 클래스에서 멤버함수를 재정의하는 이유는 어떠한 경우라도 기본클래스의 멤버함수를 버리고 파생 클래스의 멤버함수를 사용하려는 것
- 기존 클래스의 모든 내용을 모두 현재 프로그램에 사용할 수 있는데 특정 함수가 걸맞지 않을 경우, 기존의 클래스를 고치느니 상속을 받고 가상함수를 이용하여 마음에 들지 않는 함수만 고쳐서 사용함

## 가상함수 형식

```cpp
class 클래스명{
    virtual 리턴형 함수명(매개변수) { }
};
```

```cpp
class A {
public:
    virtual int SS(int i) { return (i * 2); }
    // 함수 재정의 시 이 함수는 무시됨
    // 함수명, 리턴형, 매개변수의 개수와 자료형은 같아야 함
};
class B : public A {
public:
    int SS(int i) { return ( i * 3 ); }
    // 부모클래스 상속받아 자식클래스 재정의
}
```

## C언어의 cast 연산자

- C 언어에서는 자료형이 서로 다른 혼합 연산에서는 기억 장소의 크기가 큰 쪽으로 통일시켜 연산이 이루어짐(자동 형 변환(implicit arithmetic conversion))
- int형과 double형의 연산에서는 int형이 double형으로 변환되어 결과가 double형으로 나옴
- 이미 지정된 자료형을 다른 자료형으로 일시적으로 강제로 바꿀 수 있는데 이것을 명시적 형 변환이라고 하며 이때 cast 연산자 사용
- 변환시키고자 하는 값이나 변수 앞에 해당 자료형을 괄호로 묶어 주면 됨
- (자료형)값_이나_변수
  - (int)x, (char)ch, (double)sum
- 우선 순위가 두 번째로 높은 연산자
- 숫자 3은 int형이지만 (double)3은 일시적으로 double형 3.0
  - 3.0 == (double)3
- 'A'는 문자이지만 (int)'A'는 숫자(ASCII코드 값) 65
- int형 65는 숫자이지만 (char)65는 ASCII코드 값 65에 해당하는 문자 'A'
  - (int)'A' //숫자 65
  - (char)65 //문자 'A
  - x/(double)y //y변수를 double형으로

## C++에서 새로 도입된 cast 연산자

- static_cast
- dynamic_cast : 안전한 downcasting
  - 부모 클래스의 포인터에서 자식 클래스의 포인터로 다운 캐스팅
- const_cast
- reinterpret_cast
- C/C++ cast 연산자
  - ``` (type)(expression) ```
  - ``` (double)x; ```
- C++ cast 연산자
  - ``` 연산자<type>(expression) ```
  - ``` static_cast<double>(x); ```

## 출처

C++프로그래밍(21-2학기)한성현교수 강의 내용 변형 및 요약  
Computer S/W, [Induk Univ][googlelink]  
한성현 교수님 -  hsh@induk.ac.kr  
C/C++ 프로그래밍 | 송재철, 한성현, 김경신 공저 | 양서각 | 2007년 03월 03일

[id]: URL "Optional Title here"
[googlelink]: https://www.induk.ac.kr "Go google"