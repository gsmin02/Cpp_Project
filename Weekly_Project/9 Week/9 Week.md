# const

## const변수

- 변수에 const라는 키워드를 사용하여 상수(constant)의 의미를 갖게 하여 그 내용을 변경할 수 없게 한다.

## 함수에 사용하는 const

- 함수 선언 시 함수, 매개변수, 리턴형에 const를 선언하여, 이들이 읽기 전용(read only)임을 나타낸다.

# const 멤버

## const 멤버

- const형 멤버함수는 해당 멤버변수를 변경하는 치환 (replacement)연산을 수행할 수 없다.
- const로 지정된 함수에서는 멤버변수의 값을 변경할 수 없다.
  - 즉, 멤버를 참조만 하는 읽기 전용 함수(앞에서 get으로 시작하는 함수)가 된다.
- const함수는 const함수만 호출할 수 있으며 일반 멤버함수에서 접근할 수 없다.
  - 일반 멤버함수에 접근하여 간접적으로 멤버변수를 변경하는 것을 막기 위해
- 생성자와 소멸자에서는 const를 사용할 수 없다.
- const형을 선언하고자 하면 멤버변수는 형 앞에 const를, 멤버함수는 함수의 괄호 다음에 const를 추가한다.
  - ``` const int age; // 멤버변수는 형 앞에 ```  
  - ``` int getAge() const; // 멤버함수는 괄호 다음에 ```  

```cpp
int getAge() const {
    return age;
}
```

## const형 멤버변수와 멤버함수

```cpp
class 클래스명 {
    const 형 멤버변수; // const 형 멤버변수
    리턴형 함수명(매개변수 리스트) const; // const 형 멤버함수
};
```

```cpp
class Dog {
    const int age; // 멤버변수는 형 앞에 const를 추가
    int getAge() const; // 멤버함수는 괄호 다음에 const를 추가
};
int Dog::getAge() const { // 멤버함수는 괄호 다음에 const를 추가가
    return age;
}
```

# const 객체

## const 객체

- 객체가 const로 지정되면 해당 객체에 초기화된 데이터는 변경할 수 없으며 const로 지정된 멤버함수만 호출할 수 있다.
- 객체를 const로 지정하려면 객체 정의 시 클래스 명 앞에 const를 추가한다.
- ``` const Dog happy; ```  
  - const 객체 happy
  - happy의 초기화된 데이터를 변경할 수 없다.

# 포인터

## 포인터 개요

- 포인터(pointer)는 C/C++ 언어를 다른 언어와 차별화시키는 가장 큰 특징
- 포인터를 이용하게 되면 기계어나 어셈블리 언어처럼 메모리의 주소를 이용해 메모리의 내용을 직접 접근할 수 있음
- 포인터가 사용되는 경우
  - call by reference로 함수로부터 한 개 이상의 값을 리턴할 때
  - 함수들 간에 배열이나 문자열을 전달할 때
  - 배열 조작을 쉽게 할 때
  - 연결 리스트(linked list)나 이진 트리(binary tree) 등 복잡한 자료 구조를 만들 때
  - 메모릴를 동적으로 할당할 때
    - ``` int *pi=(int*)malloc(100*sizeof(int)); //C ```  
    - ``` int *pi=new int[100]; //C++ ```  

## 포인터와 주소

- 메모리에는 위치를 구분하기 위해 순서대로 번호가 붙어있는데 이것을 메모리의 주소, 번지, address라 함
- ``` int sum=0; ```
  - 변수를 초기화하면서 선언하면, int형이므로 4바이트 메모리 공간이 확보되고 초기값으로 0이 할당됨
  - sum변수가 실제로 할당된 메모리의 주소를 알고 싶다면 &연산자를 사용하여 &sum이라고 하면 변수가 기억되어 있는 메모리 번지를 알 수 있음
- 메모리의 주소를 저장하려면 일반 변수가 아닌 포인터를 사용
- 포인터라고만 해도 되지만 주소를 저장하는 변수이므로 포인터 변수라고도 함

## 포인터 선언

- 포인터도 변수이므로 사용하기 전에 선언해야 함
- 자료형과 변수명 사이에 구두점 \* 를 더 쓰면 됨
- 선언문에서 쓰는 \* 는 곱하기 연산자와 전혀 관계없는 구두점
  - ``` int x; // 일반 변수 x의 선언 ```  
  - ``` int *x; // 포인터 (변수) x의 선언 ```  
  - ``` int * px; // 포인터 px의 선언 ```  
  - ``` int *px, y; // px만 포인터, y는 일반 변수 ```  
  - ``` int *px, *py; // px, py 둘 다 포인터 ```  
- *는 자료형과 변수명 사이 아무데나 있어도 됨
  - ``` int* px; // 선언문에서 쓰는 *는 구두점으로 포인터를 선언 ```  
  - ``` int * px; ```  
  - ``` int *px; ```  

## 참조 연산자 *

- 포인터에 주소를 대입하는 방법
  - ``` int x=10; // 일반 변수 x의 선언과 초기화 ```  
  - ``` px = &x; // 포인터 px에 변수 x의 주소 대입 ```  
- 포인터는 일반적으로 일반 변수명 앞에 주소 연산자(&)를 사용해 해당 변수의 주소를 저장
- 포인터 px에는 변수 x의 주소가 들어있음
- px가 저장하고 있는 x의 주소로 가서 그 값인 10을 변수 y에 대입하려면 다음과 같이 하면 됨
  - ``` y=*px; ```  
  - 실행문에서 사용하는 \* 는 참조 연산자, 포인터의 주소로 가서 값을 가져옴
- 포인터 앞에 \* 를 찍어주면 되는데 이때 \* 는 참조 연산자
- 곱하기 연산자와 \* 와 모양은 같지만 우선 순위가 높음

## 출처

C++프로그래밍(21-2학기)한성현교수 강의 내용 변형 및 요약  
Computer S/W, [Induk Univ][googlelink]  
한성현 교수님 -  hsh@induk.ac.kr  
C/C++ 프로그래밍 | 송재철, 한성현, 김경신 공저 | 양서각 | 2007년 03월 03일

[id]: URL "Optional Title here"
[googlelink]: https://www.induk.ac.kr "Go google"
