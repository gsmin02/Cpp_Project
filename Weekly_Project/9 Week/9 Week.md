
# const

## const변수

- 변수에 const라는 키워드를 사용하여 상수(constant)의 의미를 갖게 하여 그 내용을 변경할 수 없게 한다.

## 함수에 사용하는 const

- 함수 선언 시 함수, 매개변수, 리턴형에 const를 선언하여, 이들이 읽기 전용(read only)임을 나타낸다.

# const 멤버

## const 멤버

- const형 멤버함수는 해당 멤버변수를 변경하는 치환 (replacement)연산을 수행할 수 없다.
- const로 지정된 함수에서는 멤버변수의 값을 변경할 수 없다.
  - 즉, 멤버를 참조만 하는 읽기 전용 함수(앞에서 get으로 시작하는 함수)가 된다.
- const함수는 const함수만 호출할 수 있으며 일반 멤버함수에서 접근할 수 없다.
  - 일반 멤버함수에 접근하여 간접적으로 멤버변수를 변경하는 것을 막기 위해
- 생성자와 소멸자에서는 const를 사용할 수 없다.
- const형을 선언하고자 하면 멤버변수는 형 앞에 const를, 멤버함수는 함수의 괄호 다음에 const를 추가한다.
  - ``` const int age; // 멤버변수는 형 앞에 ```  
  - ``` int getAge() const; // 멤버함수는 괄호 다음에 ```  

```cpp
int getAge() const {
    return age;
}
```

## const형 멤버변수와 멤버함수

```cpp
class 클래스명 {
    const 형 멤버변수; // const 형 멤버변수
    리턴형 함수명(매개변수 리스트) const; // const 형 멤버함수
};
```

```cpp
class Dog {
    const int age; // 멤버변수는 형 앞에 const를 추가
    int getAge() const; // 멤버함수는 괄호 다음에 const를 추가
};
int Dog::getAge() const { // 멤버함수는 괄호 다음에 const를 추가가
    return age;
}
```

# const 객체

## const 객체

- 객체가 const로 지정되면 해당 객체에 초기화된 데이터는 변경할 수 없으며 const로 지정된 멤버함수만 호출할 수 있다.
- 객체를 const로 지정하려면 객체 정의 시 클래스 명 앞에 const를 추가한다.
- ``` const Dog happy; ```  
  - const 객체 happy
  - happy의 초기화된 데이터를 변경할 수 없다.

# 포인터

## 포인터 개요

- 포인터(pointer)는 C/C++ 언어를 다른 언어와 차별화시키는 가장 큰 특징
- 포인터를 이용하게 되면 기계어나 어셈블리 언어처럼 메모리의 주소를 이용해 메모리의 내용을 직접 접근할 수 있음
- 포인터가 사용되는 경우
  - call by reference로 함수로부터 한 개 이상의 값을 리턴할 때
  - 함수들 간에 배열이나 문자열을 전달할 때
  - 배열 조작을 쉽게 할 때
  - 연결 리스트(linked list)나 이진 트리(binary tree) 등 복잡한 자료 구조를 만들 때
  - 메모릴를 동적으로 할당할 때
    - ``` int *pi=(int*)malloc(100*sizeof(int)); //C ```  
    - ``` int *pi=new int[100]; //C++ ```  

## 포인터와 주소

- 메모리에는 위치를 구분하기 위해 순서대로 번호가 붙어있는데 이것을 메모리의 주소, 번지, address라 함
- ``` int sum=0; ```
  - 변수를 초기화하면서 선언하면, int형이므로 4바이트 메모리 공간이 확보되고 초기값으로 0이 할당됨
  - sum변수가 실제로 할당된 메모리의 주소를 알고 싶다면 &연산자를 사용하여 &sum이라고 하면 변수가 기억되어 있는 메모리 번지를 알 수 있음
- 메모리의 주소를 저장하려면 일반 변수가 아닌 포인터를 사용
- 포인터라고만 해도 되지만 주소를 저장하는 변수이므로 포인터 변수라고도 함

## 포인터 선언

- 포인터도 변수이므로 사용하기 전에 선언해야 함
- 자료형과 변수명 사이에 구두점 \* 를 더 쓰면 됨
- 선언문에서 쓰는 \* 는 곱하기 연산자와 전혀 관계없는 구두점
  - ``` int x; // 일반 변수 x의 선언 ```  
  - ``` int *x; // 포인터 (변수) x의 선언 ```  
  - ``` int * px; // 포인터 px의 선언 ```  
  - ``` int *px, y; // px만 포인터, y는 일반 변수 ```  
  - ``` int *px, *py; // px, py 둘 다 포인터 ```  
- *는 자료형과 변수명 사이 아무데나 있어도 됨
  - ``` int* px; // 선언문에서 쓰는 *는 구두점으로 포인터를 선언 ```  
  - ``` int * px; ```  
  - ``` int *px; ```  

## 참조 연산자 *

- 포인터에 주소를 대입하는 방법
  - ``` int x=10; // 일반 변수 x의 선언과 초기화 ```  
  - ``` px = &x; // 포인터 px에 변수 x의 주소 대입 ```  
- 포인터는 일반적으로 일반 변수명 앞에 주소 연산자(&)를 사용해 해당 변수의 주소를 저장
- 포인터 px에는 변수 x의 주소가 들어있음
- px가 저장하고 있는 x의 주소로 가서 그 값인 10을 변수 y에 대입하려면 다음과 같이 하면 됨
  - ``` y=*px; ```  
  - 실행문에서 사용하는 \* 는 참조 연산자, 포인터의 주소로 가서 값을 가져옴
- 포인터 앞에 \* 를 찍어주면 되는데 이때 \* 는 참조 연산자
- 곱하기 연산자와 \* 와 모양은 같지만 우선 순위가 높음

## 포인터 변수의 자료형?

- ``` int *pi; ```  
  - 변수 pi가 int형 데이터를 참조하기 위한 포인터 변수
  - pi가 지시하는 곳의 자료현이 int형
- ``` char *pc; ```  
  - 변수 pc가 char형 데이터를 참조하기 위한 포인터 변수
  - pc가 지시하는 곳의 자료형이 char형

## s\[i\]==*(s+i)

- C\/C++에서 포인터는 배열과 연관되어 많이 사용됨
- 다른 언어에서 배열은 반드시 첨자와 함께 사용하지만 C\/C++에서는 첨자 없이 배열의 이름만을 사용할 수 있음
- 배열의 이름은 그 배열의 시작 주소를 저장하는 포인터
- int s\[5\]라고 배열을 선언했을 경우 첫 번째 원소는 s\[0\]이며 마지막 원소는 s\[4\]
- 이를 포인터 형식으로 표현하면 \*s, \*(s+4)
- 배열의 이름 s는 첫 번째 원소의 주소(&s\[0\])를 저장하는 포인터이므로 그 곳의 내용을 참조(*s)하면 그 값이 s\[0\]
- 일차원 배열에서 이러한 특성을 일반화
  - ``` s ==&s[0], s+1==&s[1], s+2==&s[2],..... ```  
  - ``` s+i==&s[i] ```  
  - ``` *(s+i)==*&s[i]==s[i] ```  

# 동적 메모리 항당 (new, delete)

## 지역(local) 변수와 전역(global) 변수

- 변수의 유효범위(scope)란 프로그램 내에서 변수가 사용될 수 있는 범위
  - C/C++에서는 지역(local)과 전역(global) 이라는 개념으로 변수가 사용될 수 있는 범위를 지정
- 지역 변수는 해당 함수나 블록({ }) 내에서만 사용할 수 있고 전역 변수는 소스 전체에서 사용할 수 있음
- 지역 변수와 전역 변수는 변수의 선언 위치에 따라서 결정됨
  - 함수나 블록 안에서 변수를 선언하면 그 변수는 지역 변수가 되고, 함수 (보통 main()함수)밖에서 선언하면 전역 변수가 됨

## 코드 영역과 데이터 영역

- C/C++ 프로그램은 소스와 프로그램에서 사용할 데이터로 구성됨
- 소스는 컴파일과 링킹 과정을 거쳐 기계어로 번역됨
- 기계어로 번역된 코드는 메모리의 코드(code)영역에 저장됨
  - 코드 영역은 저장된 내용을 읽기만 가능하고 쓰기가 불가능한 메모리 영역
- 프로그램에서 사용할 변수 등의 데이터는 읽기 쓰기가 가능한 데이터 영역에 저장됨
  - 데이터 영역은 비초기화된 데이터가 저장되는 bss, 초기화된 데이터가 저장되는 데이터 영역으로 나눔
- 지역 변수는 스택 영역을 사용하고 전역 변수는 데이터 영역을 사용

## 컴퓨터의 프로그램 메모리 레이아웃

- 지역변수
  - 자신의 지역({ }) 내에서만 유효하다.
  - 함수가 반환되면 지역변수는 사라진다.
- 전역변수
  - 프로그램이 끝날 때까지 값을 유지한다
  - 프로그램의 모든 부분에서 접근 가능하다.
  - 이해하기 어렵고 유지보수 어렵다.
- 동적메모리할당
  - 지역변수인데도 할당 받은 메모리를 해제(delete)하기 전까지 값을 유지

## 동적 메모리를 사용하는 이유

- 지역 변수는 자신의 지역({ }) 내에서만 유효한데, 전역변수처럼 프로그램이 끝날 때까지 값을 유지하고 싶은 경우
- 프로그램 작성시(컴파일시)는 필요한 메모리 공간의 크기를 모르겠고, 프로그램을 실행할 때(runtime) 메모리의 양을 결정해야 하는 경우
  - 사용자 입력에 필요한 메모리 공간을 확보하는 경우
- 지금까지는 프로그램을 실행하기 전에 고정된 크기를 가지도록 변수, 배열, 객체를 선언
  - ``` int x[1000]; //크기는 넉넉하게 ```  
  - 그러나 지역 변수가 저장되는 스택은 한정되어 있어서 너무 큰 크기는 할당 어려움
    - 스택 공간이 부족하면 stack overflow 오류
    - heap에 할당해야 함
- 실행 시간에 할당되어 사용되는 메모리 블록
  - heap
- 동적메모리의 단점
  - 스택보다 느림
  - 동적으로 확보된 기억공간은 기억공간에 이름이 없기 때문에 주소를 사용하므로 포인터에 대한 이해가 필요

## 정적 vs. 동적 메모리 할당

- 정적 메모리 할당
  - 컴파일시 필요한 메모리 할당
  - 배열 : int array\[32\]; // 항상128byte 공간 확보
  - 사용하지 않는 메모리까지 충분히 잡아 낭비
  - 너무 큰 메모리는 할당 불가
  - 보통 수 kB까지는 스택 사용, 그 이상은 heap에 할당
  - [Visual Studio][link]에서 기본 스택 크기는 1MB

- 동적 메모리 할당
  - 실행시 필요한 메모리(heap) 할당
  - 필요한 만큼만 잡음
  - 메모리의 주소를 사용(포인터 이용)하여 접근
  - malloc()/free() 사용 // C
  - new/delete사용 // C++
    - new : 메모리 할당, 할당된 메모리 시작주소 리턴됨
    - delete : 할당 받은 메모리 해제

## 동적 메모리할당: C vs. C++

- C에서 동적 메모리 할당을 할 경우 malloc() 함수를 사용
  - 할당된 메모리를 해제하기 위해서 free()함수를 사용
- 이러한 표준 함수들은 C++에서도 사용할 수 있지만 C++에서는 메모리를 할당하고 해제하는데 더 편리하고 안전한 방법을 사용
- C++
  - 메모리를 할당할 때 new를 사용
  - 할당된 메모리를 해제할 때 delete를 사용

## 동적 메모리의 할당과 해제: new와 delete

- 기본 자료형
  - 할당

      ```cpp
      int *pi=new int;
      int *pi=new int(2); //초기값을 줄 경우
      ```

  - 해제

    ```cpp
    delete pi;
    ```

- 배열
  - 할당

    ```cpp
    int *pi=new int[5] ;
    ```

  - 해제

    ```cpp
    delete []pi; //주의: []써야 함
    ```

## new와 delete

- new는 메모리를 동적으로 할당하고, 할당된 메모리에 대한 주소를 반환하는 연산자이다.
  - malloc() 함수와 마찬가지로, 요구한 만큼의 메모리가 충분하지 않으면 new는 null포인터를 반환한다.
  - ``` int *pi=new int; ```
  - ``` int *pi = (int *)malloc(sizeof(int)); ```

- delete는 free()함수와 마찬가지로, 더 이상 필요 없는 메모리를 해제한다.
  - ``` delete pi; ```
  - ``` free(pi); ```
  - 해제하지 않으면 메모리 누수(leak)가 발생하여 다른 프로그램에서도 해당 메모리는 사용하지 못한다.

## new와 delete의 장점

- new와 delete는 malloc()과 free()에 비해 몇 가지 장점이 있다.
- new는 지정된 형의 크기만큼 메모리를 자동적으로 할당해 준다.
- 즉, 필요한 메모리 크기를 계산하기 위해 sizeof()와 같은 연산자가 필요 없다.
  - ``` int *pi=new int; ```
  - ``` int *pi = (int *)malloc(sizeof(int)); ```
- new는 지정된 형의 포인터(메모리 시작주소)를 자동적으로 반환한다.
- new와 delete는 중첩이 가능하다.
- 동적으로 할당된 객체를 초기화할 수 있다.
  - 생성자를 자동으로 호출한다.
- malloc.h나 stdlib.h를 포함할 필요 없다.

## 출처

C++프로그래밍(21-2학기)한성현교수 강의 내용 변형 및 요약  
Computer S/W, [Induk Univ][googlelink]  
한성현 교수님 -  hsh@induk.ac.kr  
C/C++ 프로그래밍 | 송재철, 한성현, 김경신 공저 | 양서각 | 2007년 03월 03일

[id]: URL "Optional Title here"
[googlelink]: https://www.induk.ac.kr "Go google"
[link]: https://stackoverflow.com/questions/1825964/c-c-maximum-stack-size-of-program/1826072